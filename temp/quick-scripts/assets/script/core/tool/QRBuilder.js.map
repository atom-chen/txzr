{"version":3,"sources":["QRBuilder.ts"],"names":[],"mappings":";;;;;AAAA,iDAA6C;AAG7C;;GAEG;AAEH;IAAA;IAsCA,CAAC;IApCiB,eAAK,GAAnB,UAAoB,OAAe,EAAE,IAAkB;QAAlB,qBAAA,EAAA,UAAkB;QACnD,IAAI,CAAC,OAAO,EAAE;YACV,kBAAM,CAAC,2BAA2B,CAAC,CAAA;YACnC,OAAM;SACT;QACD,IAAM,MAAM,GAAG,IAAI,MAAM,CAAC,CAAC,CAAC,EAAE,mBAAmB,CAAC,CAAC,CAAC,CAAA;QACpD,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;QACvB,MAAM,CAAC,IAAI,EAAE,CAAA;QAEb,IAAM,MAAM,GAAG,IAAI,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QACpC,MAAM,CAAC,cAAc,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAA;QACtC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;QAEjC,IAAM,GAAG,GAAG,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAA;QAC5C,GAAG,CAAC,SAAS,GAAG,EAAE,CAAC,KAAK,CAAC,KAAK,CAAA;QAE9B,IAAM,KAAK,GAAG,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,cAAc,EAAE,CAAA;QACpD,IAAM,KAAK,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,cAAc,EAAE,CAAA;QAErD,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,cAAc,EAAE,EAAE,GAAG,EAAE,EAAE;YACpD,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,cAAc,EAAE,EAAE,GAAG,EAAE,EAAE;gBACpD,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE;oBACzB,GAAG,CAAC,SAAS,GAAG,EAAE,CAAC,KAAK,CAAC,KAAK,CAAA;iBACjC;qBAAM;oBACH,GAAG,CAAC,SAAS,GAAG,EAAE,CAAC,KAAK,CAAC,KAAK,CAAA;iBACjC;gBACD,IAAM,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAA;gBAClE,IAAM,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAA;gBAClE,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;gBAChE,GAAG,CAAC,IAAI,EAAE,CAAA;aACb;SACJ;QAED,OAAO,MAAM,CAAA;IACjB,CAAC;IAEL,gBAAC;AAAD,CAtCA,AAsCC,IAAA","file":"","sourceRoot":"../../../../../../assets/script/core/tool","sourcesContent":["import { errlog } from \"../helper/LogHelper\";\n\n\n/**\n * 二维码生成器\n */\n\nexport default class QRBuilder{\n\n    public static getQR(content: string, size: number = 100): cc.Node {\n        if (!content) {\n            errlog('getQR content is undifine')\n            return \n        }\n        const qrcode = new QRCode(-1, QRErrorCorrectLevel.H)\n        qrcode.addData(content)\n        qrcode.make()\n        \n        const qrNode = new cc.Node('qrNode')\n        qrNode.setAnchorPoint(cc.v2(0.5, 0.5))\n        qrNode.setContentSize(size, size)\n        \n        const ctx = qrNode.addComponent(cc.Graphics)\n        ctx.fillColor = cc.Color.BLACK\n\n        const tileW = qrNode.width / qrcode.getModuleCount()\n        const tileH = qrNode.height / qrcode.getModuleCount()\n\n        for (let row = 0; row < qrcode.getModuleCount(); row++) {\n            for (let col = 0; col < qrcode.getModuleCount(); col++) {\n                if (qrcode.isDark(row, col)) {\n                    ctx.fillColor = cc.Color.BLACK\n                } else {\n                    ctx.fillColor = cc.Color.WHITE\n                }\n                const w = (Math.ceil((col + 1) * tileW) - Math.floor(col * tileW))\n                const h = (Math.ceil((row + 1) * tileW) - Math.floor(row * tileW))\n                ctx.rect(Math.round(col * tileW), Math.round(row * tileH), w, h)\n                ctx.fill()\n            } \n        }\n\n        return qrNode\n    }\n\n}\n"]}